\documentclass[11pt, a4paper]{article}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}

\title{\textbf{Oral Exam Notes: Static Program Reduction via Type-Directed Slicing}}
\author{Group 3: Specimin}
\date{Time Limit: 5 Minutes}

\begin{document}

\maketitle

\section*{1. The Problem (0:00 - 1:00)}
\begin{itemize}
    \item \textbf{Context:} Typecheckers (like \texttt{javac} or the Checker Framework) often crash or produce false positives on large, complex codebases.
    \item \textbf{The Conflict:} Users report bugs but provide massive codebases. Maintainers need a \textit{minimal} reproduction case to fix the bug.
    \item \textbf{Why existing tools fail:} Existing reducers (like \textit{Perses} or \textit{C-Reduce}) are \textbf{dynamic}. They require the code to be runnable and run the typechecker repeatedly (thousands of times). This is:
    \begin{enumerate}
        \item Too slow (hours/days).
        \item Impossible if the user cannot provide the full build environment/dependencies.
    \end{enumerate}
\end{itemize}

\section*{2. The Solution: Specimin (1:00 - 2:00)}
\begin{itemize}
    \item \textbf{Core Insight:} Typecheckers are \textbf{modular}. To typecheck a method, you don't need the implementation of its dependencies; you only need their \textbf{type signatures}.
    \item \textbf{Proposal:} A static tool called \textbf{Specimin} that performs \textit{Type-Directed Slicing}.
    \item \textbf{Goal:} Create a standalone, minimal program that preserves the \textit{compile-time behavior} (the bug) without preserving runtime semantics.
\end{itemize}


\section*{3. Methodology (2:00 - 3:00)}
\begin{itemize}
    \item \textbf{Type Rule Dependency Map:} They inverted the Java type rules. If a type rule says "To typecheck expression $E$, I need the type of variable $X$", Specimin maps $E \to X$.
    \item \textbf{Two Modes of Operation:}
    \begin{itemize}
        \item \textbf{Exact Mode:} Requires full source code. Guarantees behavior preservation.
        \item \textbf{Approximate Mode (The "Killer Feature"):} Works on \textbf{incomplete code}. If a class is missing (e.g., a library), Specimin \textit{synthesizes} a dummy class/stub with the necessary structure to make the typechecker happy.
    \end{itemize}
    \item \textbf{Algorithm:} It uses a worklist algorithm. It starts at the slicing criterion (the crash location) and iteratively adds dependencies based on the Type Rule Map.
\end{itemize}

\section*{4. Evaluation (3:00 - 4:00)}
\begin{itemize}
    \item \textbf{Dataset:} Tested on 28 historical bugs from \textit{javac}, \textit{NullAway}, and \textit{Checker Framework}.
    \item \textbf{Effectiveness:}
    \begin{itemize}
        \item Preserved the bug behavior in \textbf{89\%} of cases using Approximate Mode (no classpath needed).
        \item \textbf{93\%} success in Exact Mode.
    \end{itemize}
    \item \textbf{Performance:} Extremely fast. Average runtime was \textbf{15 seconds}, whereas dynamic reducers typically take much longer.
    \item \textbf{Reduction Size:} Reduced million-line programs to an average of \textbf{116 lines}.
\end{itemize}

\section*{5. Critique \& Conclusion (4:00 - 5:00)}
\begin{itemize}
    \item \textbf{Strengths:}
    \begin{itemize}
        \item \textbf{Handling Incomplete Code:} This is the biggest contribution. It removes the "it works on my machine" barrier for reporting bugs.
        \item \textbf{Speed:} Static analysis is orders of magnitude faster than dynamic reduction.
    \end{itemize}
    \item \textbf{Weaknesses (Crucial for exam):}
    \begin{itemize}
        \item \textbf{Language Specific:} Relies on manually mapping Java type rules. Hard to port to C++ or Python.
        \item \textbf{Oversizing:} The output (119 lines) is about 6x larger than human-minimized code (19 lines) because it is conservative.
        \item \textbf{Scope:} Only works for typecheckers, not logic bugs or runtime crashes.
    \end{itemize}
\end{itemize}

\end{document}