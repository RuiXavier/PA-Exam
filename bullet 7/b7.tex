\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}

% Styling to match the "PDF Structure" (Clean headers, Whiteboard blocks)
\newtcolorbox{whiteboard}[1][]{
  colback=gray!5,
  colframe=black!70,
  title=\textbf{Whiteboard Action},
  fonttitle=\bfseries,
  sharp corners,
  boxrule=1pt,
  #1
}

\title{\textbf{CFL Reachability \& Datalog}}
\author{Candidate}
\date{}

\begin{document}

\maketitle

\section*{Introduction (Approx. 2 Minutes)}

Good morning.
Today I will be presenting two frameworks: \textbf{Context-Free Language (CFL) Reachability} and \textbf{Datalog}.
While I will connect them in the context of static analysis, it is important to note that they are distinct tools.
CFL Reachability is a formal language framework used to filter graph paths, whereas Datalog is a general-purpose declarative logic language used in databases, networking, and complexity theory.

My agenda is as follows:
\begin{itemize}
    \item First, I will explain **CFL Reachability**, starting with a general example and moving to the specific "Dyck" formulation used in analysis.
    \item I will discuss the "Interleaved Dyck" problem and the undecidability issues that arise when combining different sensitivities.
    \item Second, I will present **Datalog** as a powerful logic solver, focusing on its semantics, negation paradoxes, and how it captures polynomial-time algorithms.
\end{itemize}

\begin{whiteboard}
\begin{itemize}
    \item \textbf{Title:} CFL Reachability \& Datalog
    \item \textbf{Agenda:}
    \begin{enumerate}
        \item CFL Reachability (General $\to$ Dyck $\to$ Interleaved)
        \item Datalog (Semantics, Negation, PTime)
    \end{enumerate}
\end{itemize}
\end{whiteboard}

\vspace{1em}
\hrule
\vspace{1em}

\section*{Part 1: CFL Reachability}

\subsection*{General CFL Reachability}
Standard graph reachability checks if any path exists from node $A$ to $B$. In program analysis, this is too imprecise because many paths in the graph represent invalid executions.
We constrain these paths using a Context-Free Language.

Before we look at code analysis, let's look at a "normal" CFL example: **Palindromes**.
Imagine a graph where edges are labeled with letters $a$ and $b$. We want to find a path that reads the same forwards and backwards (e.g., $a \to b \to b \to a$).
We can describe this with a grammar:
\[ S \rightarrow a S a \mid b S b \mid \epsilon \]

\begin{whiteboard}
\textbf{Draw Palindrome Example:}
\begin{itemize}
    \item Edges: $1 \xrightarrow{a} 2 \xrightarrow{b} 3 \xrightarrow{b} 4 \xrightarrow{a} 5$
    \item Path string: $abba$
    \item Reduction: $a(b(\epsilon)b)a \to a(b)a \to \epsilon$ (Valid)
\end{itemize}
\end{whiteboard}

If the path string can be reduced to $\epsilon$ using the grammar, the nodes are reachable.

\subsection*{Dyck Reachability (Context Sensitivity)}
In program analysis, we don't usually care about palindromes. We care about **matched pairs**, like open and close parentheses. This is called **Dyck Reachability**.
Function calls are "open" parentheses $(_i$ and returns are "close" parentheses $)_i$.
A valid execution path must have balanced parentheses:
\[ S \rightarrow (_i S )_i \mid SS \mid \epsilon \]
If method A calls B, B must return to A, not C. This filters out "impossible" paths in the control flow graph.

\subsection*{Field Sensitivity via Dyck}
We can apply this exact same logic to heap analysis, known as **Field Sensitivity**.
Standard pointer analysis might confuse data flowing through different fields of an object.
We model a write to a field `x.f = y` as an open bracket $[_f$ and a read `z = x.f` as a close bracket $]_f$.

\begin{whiteboard}
\textbf{Field Sensitivity Example:}
\begin{itemize}
    \item Flow: $y \xrightarrow{[_f} x \xrightarrow{]_f} z$
    \item Meaning: $y$ is written to field $f$ of $x$, then read back into $z$.
    \item Matches $[_f \dots ]_f$.
    \item Mismatch: $y \xrightarrow{[_f} x \xrightarrow{]_g} z$ (Writing field $f$ but reading field $g$ is invalid).
\end{itemize}
\end{whiteboard}

\subsection*{The Problem of Interleaved Dyck Reachability}
In a perfect world, we would track **both** function calls (Context Sensitivity) and heap accesses (Field Sensitivity) perfectly.
This requires intersecting two Dyck languages:
\begin{itemize}
    \item $L_1$: Matched calls/returns $(_i \dots )_i$
    \item $L_2$: Matched writes/reads $[_f \dots ]_f$
\end{itemize}
We need to find a \textbf{single path} $P$ such that the string of labels on $P$ satisfies both grammars simultaneously ($w \in L_1 \cap L_2$).
This problem, **Interleaved Dyck Reachability**, is undecidable.

\begin{whiteboard}
\textbf{The Approximation Problem:}
Why can't we just solve them separately?
\begin{itemize}
    \item If we say "Reachable if Path A satisfies $L_1$ AND Path B satisfies $L_2$"...
    \item We might find that function flow allows a path through `foo()`, but data flow requires a path through `bar()`.
    \item Since the execution cannot take two different paths at once, this is an over-approximation.
\end{itemize}
\end{whiteboard}

\vspace{1em}
\hrule
\vspace{1em}

\section*{Part 2: Datalog}

\subsection*{Datalog as a General Framework}
Now I will move to **Datalog**. While we use it to solve reachability, it is actually a general declarative logic language used for databases, networking, and data integration.
In Datalog, we focus on the \textbf{what}, not the \textbf{how}.
It is powerful enough to express \textbf{any polynomial-time algorithm} (The complexity class PTime).

A program consists of:
\begin{itemize}
    \item **Facts:** The input data (Extensional Database).
    \item **Rules:** Logical inferences (Intensional Database).
\end{itemize}

\subsection*{Negation and Paradoxes}
Simple Datalog is purely positive (monotonic). If we add **Negation** (`not`), we run into logical paradoxes where no minimal model exists.
Consider this voting example from the slides:

\begin{whiteboard}
\textbf{The Voting Paradox:}
\begin{verbatim}
voteTrump(X)  :- vote(X), not voteHarris(X).
voteHarris(X) :- vote(X), not voteTrump(X).
vote(John).
\end{verbatim}
\end{whiteboard}

If John votes, the first rule says he votes Trump if he didn't vote Harris. The second says he votes Harris if he didn't vote Trump.
Depending on where you start, you get contradictory results. There is no defined "Least Fixed Point" here.

\subsection*{Stratified Datalog}
To solve this, we use **Stratification**.
We interpret the rules in layers (strata).
We construct a Precedence Graph of predicates:
\begin{itemize}
    \item If rule $A \leftarrow B$ exists, draw edge $B \to A$.
    \item If rule $A \leftarrow \text{not } B$ exists, draw a "negative edge" $B \overset{\neg}{\to} A$.
\end{itemize}
A program is valid (stratified) only if there are **no cycles containing a negative edge**. This ensures we fully compute the "negated" facts (lower layer) before using them in the upper layer.

\vspace{1em}
\hrule
\vspace{1em}

\section*{Conclusion}

To summarize:
\begin{enumerate}
    \item **CFL Reachability** gives us a way to define valid paths using grammars. We looked at the Palindrome example, generalized it to Dyck for function/field matching, and saw that combining two Dyck languages (Interleaved) leads to undecidability.
    \item **Datalog** is the solver engine. It captures all PTime algorithms but requires care with Negation (solved via Stratification) to maintain well-defined semantics.
\end{enumerate}

Using Datalog to implement CFL reachability allows us to write concise, correct static analysis algorithms that are efficient to solve.

Thank you.

\end{document}