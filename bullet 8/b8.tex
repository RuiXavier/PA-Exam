\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb, amsmath}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{mathrsfs}

% ----------------------------------------------------------------------
% STYLE DEFINITIONS (Matching the PDF Structure)
% ----------------------------------------------------------------------

% Custom box for Whiteboard Actions
\newtcolorbox{whiteboard}{
    colback=white,
    colframe=black,
    title=\textsc{Whiteboard Action:},
    fonttitle=\bfseries,
    sharp corners,
    boxrule=1pt,
    left=5mm,
    bottom=5mm,
    top=5mm
}

% Command for spoken text segments
\newcommand{\script}[1]{
    \vspace{0.3cm}
    \noindent #1
    \vspace{0.3cm}
}

% Title Format
\title{\textbf{Abstract Interpretation}\\ \large Chapter 12: Collecting Semantics \& Galois Connections}
\author{Oral Exam Script}
\date{Target: 15 Minutes}

\begin{document}

\maketitle

% ----------------------------------------------------------------------
% INTRODUCTION
% ----------------------------------------------------------------------
\section*{1. Introduction (Approx. 2 Minutes)}

\script{
Good morning. Today I will be presenting Chapter 12 on Abstract Interpretation.

In the previous parts of this course, we have built various static analyses intuitively. However, a critical question remains: \textit{How do we verify that these analyses are actually correct?}

We know from Rice's Theorem that calculating non-trivial properties of runtime behavior perfectly is undecidable. We cannot compute the exact set of all possible states for infinite loops or recursive structures.

To solve this, we use Abstract Interpretation. This is a formal mathematical framework that bridges the gap between the infinite "Concrete" execution of a program and a finite "Abstract" approximation.

My goal is to show how we define the "Ground Truth" (Collecting Semantics) and strictly link it to our analysis using Galois Connections to guarantee Soundness.
}

\begin{whiteboard}
\begin{itemize}
    \item \textbf{The Problem:} Undecidability (Rice's Theorem).
    \item \textbf{The Solution:} Finite Approximation.
    \item \textbf{Concrete Domain ($C$):} $\mathcal{P}(\mathbb{Z})$ (e.g., $\{0, 2, 4, \dots\}$)
    \item \textbf{Abstract Domain ($A$):} Signs, Intervals, Parity, etc.
\end{itemize}
\end{whiteboard}

% ----------------------------------------------------------------------
% PART 1: THE FRAMEWORK & GALOIS CONNECTIONS
% ----------------------------------------------------------------------
\section*{Part 1: The Framework \& Galois Connections (4 Minutes)}

\script{
To perform this analysis formally, we need two domains and a strict way to translate between them.
First, we have the \textbf{Collecting Semantics}. This represents the ground truthâ€”the set of all concrete states reachable at a program point.
Since this set is often infinite, we map it to a finite \textbf{Abstract Domain} ($L$).

To link them, we define a \textbf{Galois Connection}, which consists of two monotone functions:
1. \textbf{Abstraction ($\alpha$):} Maps a concrete set to its "best" abstract representation.
2. \textbf{Concretization ($\gamma$):} Maps an abstract value back to the set of real values it represents.
}

\begin{whiteboard}
\textbf{The Galois Connection Pair $(\alpha, \gamma)$:}
\begin{enumerate}
    \item \textbf{Extension (Safety):} 
    \[ x \subseteq \gamma(\alpha(x)) \]
    \item \textbf{Reduction (Precision):} 
    \[ \alpha(\gamma(y)) \sqsubseteq y \]
\end{enumerate}
\textbf{The Adjunction (Shortcut):}
\[ \alpha(x) \sqsubseteq y \iff x \subseteq \gamma(y) \]
\end{whiteboard}

\script{
For this pair to be a valid Galois Connection, it must satisfy two specific properties.

The first is \textbf{Extension}. This is our \textbf{Safety} guarantee.
It says: If you abstract a value and then concretize it back, the result must be \textit{larger or equal} to what you started with.
We are allowed to add "noise" (imprecision), but we are strictly forbidden from losing original data.

The second is \textbf{Reduction}. This is our \textbf{Precision} guarantee.
It says: If you concretize an abstract value and re-abstract it, you must get a result \textit{smaller or equal} to the original.
This forces $\alpha$ to pick the most specific symbol available. It prevents the abstraction from being "lazy" and just returning $\top$ (Unknown) for everything.

Finally, we often combine these into the \textbf{Adjunction Property}.
This is a powerful shortcut: It tells us that checking if a concrete set $x$ is safely represented by abstract value $y$ is mathematically identical to checking if $x$ is contained in the concretization of $y$.
}

% ----------------------------------------------------------------------
% PART 2: OPTIMALITY & COMPLETENESS
% ----------------------------------------------------------------------
\section*{Part 2: Precision - Optimality \& Completeness (Approx. 5 Minutes)}

\script{
Now that we have Soundness (safety), we must ask: Is our analysis *good*? 
We define "good" using two concepts: \textbf{Optimality} and \textbf{Completeness}.

First, \textbf{Optimality}. This concept applies to our transfer functions (the rules we write for operations like $+$ or $-$). 
Optimality basically asks: \textit{Is this rule as precise as it mathematically can be, given our abstract domain?}

The mathematical definition provides a recipe for deriving the perfect rule:
}

\begin{whiteboard}
\textbf{Optimality (The "Best" Local Rule):}
\[ af_{opt} = \alpha \circ cf \circ \gamma \]
\textbf{Recipe:}
\begin{enumerate}
    \item \textbf{Concretize ($\gamma$):} Go to the real world.
    \item \textbf{Compute ($cf$):} Do the math concretely.
    \item \textbf{Abstract ($\alpha$):} Come back to the abstract world.
\end{enumerate}
\end{whiteboard}

\script{
If we follow this loop, we get the optimal result. 
For example, consider the expression $x - x$ where the value of $x$ is unknown ($\top$).

In a naive analysis, we might say: "I don't know $x$, so I don't know $x - x$." The result would be $\top$.
But let's apply the optimality recipe:
\begin{enumerate}
    \item We concretize $\top$ to "all integers".
    \item We compute $n - n$ for every integer. The result is always $0$.
    \item We abstract $\{0\}$ to the abstract value \textbf{Zero}.
\end{enumerate}
So, the \textit{optimal} abstract result for $x - x$ is \textbf{Zero}, not $\top$. Optimality ensures we don't lose precision just because our transfer function is lazy.
}

\script{
Next is \textbf{Completeness}. This is a much stricter, global requirement. 
Completeness implies there is \textbf{zero} loss of precision during the entire analysis compared to the concrete execution.
}

\begin{whiteboard}
\textbf{Completeness (Perfect Simulation):}
\[ \alpha \circ cf = af \circ \alpha \]
\textbf{Commutative Diagram:}
\[
\begin{array}{ccc}
    Concrete & \xrightarrow{cf} & Concrete \\
    \downarrow \alpha & & \downarrow \alpha \\
    Abstract & \xrightarrow{af} & Abstract
\end{array}
\]
\end{whiteboard}

\script{
This formula represents a "Commutative Diagram." 
It says: It shouldn't matter if I calculate concretely and then abstract ($\alpha \circ cf$), or abstract first and then calculate abstractly ($af \circ \alpha$). The result should be identical.

In Abstract Interpretation, completeness is extremely rare. We almost always lose information.
Consider adding $(+1)$ and $(-1)$.
}

\begin{whiteboard}
\textbf{Example of Incompleteness:}
\begin{itemize}
    \item \textbf{Concrete Path:} $1 + (-1) = 0$. Abstraction $\to$ \textbf{Zero}.
    \item \textbf{Abstract Path:} $(+) + (-) = \top$ (could be anything).
\end{itemize}
Since $\textbf{Zero} \sqsubset \top$, the Abstract path lost precision.
\end{whiteboard}

\script{
Because the abstract calculation gave us $\top$ while the concrete calculation (abstracted) gave us \textbf{Zero}, our analysis is \textbf{Incomplete}. 
We lost the specific relationship that the magnitudes were equal.
}

% ----------------------------------------------------------------------
% PART 3
% ----------------------------------------------------------------------
\section*{Part 3: Precision \& Completeness (4 Minutes)}

\script{
Soundness means we aren't wrong, but it doesn't mean we are useful. If we always returned "Top" (Unknown), we would be sound, but useless.

We strive for two higher goals: \textbf{Optimality} and \textbf{Completeness}.

\textbf{Optimality} defines the best possible abstract function. Mathematically, it is defined by inducing the function from the concrete world:
}

\begin{whiteboard}
\textbf{Write Optimality:}
\[ af_{opt} = \alpha \circ cf \circ \gamma \]
\end{whiteboard}

\script{
\textbf{Completeness} is an even stricter requirement. Completeness implies there is NO loss of precision during the analysis.
}

\begin{whiteboard}
\textbf{Write Completeness:}
\[ \alpha \circ cf = af \circ \alpha \]
\end{whiteboard}

\script{
However, in Abstract Interpretation, completeness is rare. Consider the expression $(+1) + (-1)$.

In the concrete world, the result is exactly 0.
In the abstract world of signs, adding a Positive to a Negative results in $\top$ (it could be anything).
Because $\alpha(0) \sqsubset \top$, the analysis is Incomplete.
}

% ----------------------------------------------------------------------
% CONCLUSION
% ----------------------------------------------------------------------
\section*{Conclusion (\textless 1 Minute)}

\script{
To summarize:
\begin{itemize}
    \item We use \textbf{Collecting Semantics} to define the concrete ground truth.
    \item We use \textbf{Galois Connections} ($\alpha$ and $\gamma$) to formally link the concrete and abstract worlds.
    \item We rely on the \textbf{Soundness Square} to prove that our abstract transfer functions never miss a possible program state.
\end{itemize}

This framework provides the mathematical proof required to trust static analysis tools.

Thank you. I am happy to take any questions.
}

\end{document}