\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb, amsmath}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{fancyhdr}

% Setup for the "Board" boxes
\newtcolorbox{board}{
    colback=blue!5!white,
    colframe=blue!75!black,
    title=\textbf{\textsc{Whiteboard Action}},
    fonttitle=\bfseries,
    sharp corners=south,
    boxrule=0.5mm
}

% Setup for "Spoken" text
\newcommand{\speak}[1]{
    \vspace{0.2cm}
    \noindent\textbf{\textsc{Say:}} #1
    \vspace{0.2cm}
}

% Instructions for the speaker
\newcommand{\act}[1]{
    \noindent{\small\color{red}\textit{$\rightarrow$ [Action: #1]}}
}

\title{\textbf{Oral Exam: SPA Chapter 12}\\Abstract Interpretation (Full 15 Min Version)}
\author{Script \& Cheat Sheet}
\date{}

\begin{document}

\maketitle

\section*{0. Introduction (2 Minutes)}

\begin{board}
    Write the Agenda in the top corner (keep this visible):
    \begin{enumerate}
        \item Collecting Semantics (The Truth)
        \item Galois Connections ($\alpha, \gamma$)
        \item Soundness (The Proof)
        \item Optimality \& Completeness
    \end{enumerate}
\end{board}

\speak{Good morning/afternoon. Today I will be presenting Chapter 12 on \textbf{Abstract Interpretation}.}

\speak{In the earlier parts of this course, we learned how to build static analyses—like Sign Analysis or Constant Propagation. We built them intuitively, using lattices and flow functions. But a critical question remains: \textit{How do we know they are right?}}

\speak{If a tool tells me a variable is "Positive," can I bet my life on it? Or is it possible that, in some rare edge case, it actually becomes negative?}

\speak{Abstract Interpretation is the mathematical framework that answers this. It bridges the gap between the messy, infinite reality of running code (the concrete world) and the clean, finite world of static analysis (the abstract world).}

\speak{My goal today is to walk you through the four pillars of this framework: The Ground Truth, The Translation, The Guarantee of Safety, and finally, The Precision.}

\hrulefill

\section*{1. Collecting Semantics (4 Minutes)}

\speak{To prove our analysis is correct, we first need a reference point. We need to define exactly what the program does at runtime, without any simplification. We call this the \textbf{Collecting Semantics}.}

\speak{Imagine we run a program. At every control flow node, we record the state of the memory. If we run it again with different input, we get different states. The Collecting Semantics is the set of \textbf{all possible concrete states} that can ever exist at a specific point.}

\begin{board}
    Draw this CFG in the center of the board:
    \begin{verbatim}
          [x = 0]
             |
        [while ...] <---.
         /        \     |
      [exit]    [x = x + 2]
    \end{verbatim}
    
    Write next to the loop head:
    \[ C = \mathcal{P}(\mathbb{Z}) \]
    \[ S = \{0, 2, 4, 6, \dots\} \]
\end{board}

\speak{Let's look at this simple loop. We initialize $x$ to 0, and loops increment it by 2.
\act{Point to the loop head}
At this point in the code, what are the possible values of $x$?}

\speak{It starts at 0. Then 2. Then 4. It is the set of all even positive integers. This set, $\{0, 2, 4, \dots\}$, is the Collecting Semantics for this node.}

\speak{We define this mathematically as the Least Fixed Point of a concrete transfer function, $cf$. We are working in the Concrete Domain, $C$, which is usually the Power Set of all possible states.}

\speak{Now, why don't we just use this as our analysis? Because this set is infinite. By Rice's Theorem, calculating non-trivial properties of this set is undecidable. We literally cannot compute it for general programs. So, we must simplify.}

\newpage

\section*{2. Abstraction \& Concretization (4 Minutes)}

\speak{To simplify, we move from the Concrete Domain ($C$) to an \textbf{Abstract Domain} ($A$).
For this presentation, I will use \textbf{Sign Analysis} as the example, because it's visually clear.}

\begin{board}
    Draw the Sign Lattice clearly:
    \begin{center}
    $\top$ \\
    / \quad | \quad \textbackslash \\
    $-$ \quad $0$ \quad $+$ \\
    \textbackslash \quad | \quad / \\
    $\perp$
    \end{center}
\end{board}

\speak{Here, we have a finite lattice. To relate the infinite sets of integers ($C$) to these simple symbols ($A$), we need two translation functions.}

\begin{board}
    Write clearly:
    \[ \alpha: C \to A \quad (\text{Abstraction}) \]
    \[ \gamma: A \to C \quad (\text{Concretization}) \]
\end{board}

\speak{1. \textbf{Abstraction ($\alpha$)}: Maps a set of values to the "best" abstract representation. For example, $\alpha(\{2, 4, 100\}) = +$.}

\speak{2. \textbf{Concretization ($\gamma$)}: Maps an abstract value back to the \textit{meaning} it holds. For example, $\gamma(+)$ is the set of all positive integers $\{1, 2, 3, \dots\}$.}

\speak{These two cannot just be random functions. They must form a \textbf{Galois Connection}. This requires two specific properties.}

\begin{board}
    Write the properties:
    \begin{enumerate}
        \item $c \subseteq \gamma(\alpha(c))$ \quad (Extensive)
        \item $\alpha(\gamma(a)) \sqsubseteq a$ \quad (Reductive)
    \end{enumerate}
\end{board}

\speak{The first one—Extensivity—is the most important for safety.
\act{Point to property 1}
It says: If I take a concrete set $c$, translate it to abstract, and then translate it back... I must get a set that is \textbf{larger than or equal to} where I started.}

\speak{Think of it like taking a low-resolution photo. You lose the fine details (the specific numbers), but the "truth" (the fact that they are positive) is still captured inside the blurry image. We added noise, but we didn't lose the subject. This ensures we never overlook a possible runtime behavior.}

\hrulefill

\section*{3. Soundness (3 Minutes)}

\speak{Now we can define \textbf{Soundness}.
An analysis is sound if the abstract result safely over-approximates the collecting semantics.}

\begin{board}
    Write:
    \[ \alpha(\text{Real}) \sqsubseteq \text{Analysis} \]
\end{board}

\speak{To prove this, we don't check the whole program at once. We check it instruction by instruction. We use a diagram to compare the Concrete Step ($cf$) vs. the Abstract Step ($af$).}

\begin{board}
    Draw the Soundness Square (Make this big!):
    \[
    \begin{array}{ccc}
         C & \xrightarrow{\quad cf \quad} & C \\
         \alpha \Big\downarrow & & \Big\downarrow \alpha \\
         A & \xrightarrow{\quad af \quad} & A
    \end{array}
    \]
    
    Write the inequality:
    \[ \alpha(cf(c)) \sqsubseteq af(\alpha(c)) \]
\end{board}

\speak{Let's trace this.
\act{Trace the path: Right then Down}
If we run the code concretely ($cf$) and then abstract the result...
\act{Trace the path: Down then Right}
That result must be \textbf{less than or equal to} ($\sqsubseteq$) what we get if we abstract first, and then run the analysis function ($af$).}

\speak{In plain English: "The analysis calculation ($af$) must cover everything that actually happens in the code ($cf$)."
If this holds for every operation (plus, minus, assign), then the Tarski Fixed Point Theorem guarantees the whole analysis is sound.}

\newpage

\section*{4. Optimality \& Completeness (2 Minutes)}

\speak{Soundness just means "don't be wrong." But we also want to be precise. This brings us to \textbf{Optimality} and \textbf{Completeness}.}

\speak{\textbf{Optimality} is about defining the best possible abstract function.}

\begin{board}
    Write:
    \[ af_{opt} = \alpha \circ cf \circ \gamma \]
\end{board}

\speak{If we define our abstract addition by: concretizing the inputs, adding them effectively, and abstracting the result, we have the optimal definition.}

\speak{However, even optimal functions can lose information. If we have NO loss of precision, we call it \textbf{Complete}.}

\begin{board}
    Write:
    \[ \alpha \circ cf = af \circ \alpha \]
\end{board}

\speak{Notice the equals sign. This rarely happens. Sign analysis is \textbf{Incomplete} for addition.}

\begin{board}
    Write:
    \[ (+1) + (-1) = 0 \]
    \[ \alpha(\text{result}) = \text{"0"} \]
    \[ \text{vs} \]
    \[ (+) \oplus (-) = \top \]
\end{board}

\speak{Concrete math gives us 0. Abstract math adds a positive and a negative, which results in "Top" (Unknown).
Since Top is less precise than "0", the analysis is incomplete. It's safe, but fuzzy.}

\hrulefill

\section*{5. Conclusion (Top of the hour)}

\speak{To wrap up:
Abstract Interpretation allows us to formally verify static analysis.
We use \textbf{Collecting Semantics} as our ground truth.
We use \textbf{Galois Connections} to translate that truth into a computable lattice.
And we use the \textbf{Soundness Theorem} to prove that our tool never misses a bug.}

\speak{Thank you. I am ready for your questions.}

\newpage

% ------------------------------------------------------------------
% CHEAT SHEET
% ------------------------------------------------------------------

\section*{Cheat Sheet: SPA Chapter 12}
\textit{(Keep this on the table for quick reference)}

\subsection*{1. Key Definitions}
\begin{itemize}
    \item \textbf{Collecting Semantics:} The ground truth. The set of all concrete states reachable at a program point. $C = \mathcal{P}(States)$.
    \item \textbf{Abstraction ($\alpha$):} $C \to A$. Maps concrete sets to abstract values.
    \item \textbf{Concretization ($\gamma$):} $A \to C$. Maps abstract values to concrete sets.
    \item \textbf{Galois Connection:} The pair $(\alpha, \gamma)$ such that:
    \begin{itemize}
        \item $c \subseteq \gamma(\alpha(c))$ (Extensive / Safe)
        \item $\alpha(\gamma(a)) \sqsubseteq a$ (Reductive / Precise)
    \end{itemize}
\end{itemize}

\subsection*{2. The Soundness Proof (The Square)}
Diagram:
\[
    \begin{array}{ccc}
         C & \xrightarrow{\quad cf \quad} & C \\
         \alpha \Big\downarrow & & \Big\downarrow \alpha \\
         A & \xrightarrow{\quad af \quad} & A
    \end{array}
\]
Equation: $\alpha(cf(c)) \sqsubseteq af(\alpha(c))$ \\
\textit{"Abstract simulation over-approximates concrete execution."}

\subsection*{3. Precision}
\begin{itemize}
    \item \textbf{Optimality:} The best possible $af$. Defined as $af = \alpha \circ cf \circ \gamma$.
    \item \textbf{Completeness:} No loss of precision. Defined as $\alpha \circ cf = af \circ \alpha$.
    \item \textbf{Example of Incompleteness:} $(+) + (-) = \top$. We lost the fact that $1 + (-1) = 0$.
\end{itemize}

\subsection*{4. "Emergency" Q\&A Answers}
\begin{description}
    \item[Q: Why do we need Fixed Points?]
    A: We are analyzing loops. The state depends on itself. By Tarski's Theorem, because our lattice is complete and functions are monotone, a least fixed point exists.
    
    \item[Q: What is Widening?]
    A: If the lattice has infinite height (like Intervals $[a, b]$), standard iteration might not terminate. Widening ($\nabla$) forces convergence by jumping up the lattice (e.g., setting a bound to $\infty$).
    
    \item[Q: What is Trace Semantics?]
    A: Instead of just collecting states at nodes, we collect entire execution histories (traces). It's a more detailed form of collecting semantics, useful for historical properties.
\end{description}

\end{document}